module Lexer

from "bigint" include BigInt
from "set" include Set
from "char" include Char
from "string" include String
from "list" include List
from "./iter.gr" include Iter
from "option" include Option
from "runtime/unsafe/wasmi32" include WasmI32
from "runtime/unsafe/offsets" include Offsets
from "result" include Result
from "runtime/dataStructures" include DataStructures
from "./upper.gr" include Upper
from "runtime/unsafe/conv" include Conv

use Upper.{ upper_set }
use Set.Immutable.{ type Set } 
use Iter.{ type Iter, type IterResult }
use Conv.{ wasmI32ToNumber }

provide type CodePoint = Number

provide enum Token {
  Name(String, Number),
  Type(String, Number),
  Symbol(String, Number),
  Keyword(String, Number),
  // negative, value, signed, size, offset 
  Integer(Bool, BigInt, Bool, Number, Number),
  Float(Bool, BigInt, BigInt, Bool, BigInt, Number),
  Whitespace(Number),
  Unknown(Number),
  EOF(Number),
}

provide type CodePointIter = Iter<(CodePoint, Number)>

provide type CodePointPredicate = (CodePoint) => Bool


provide let (|.) = (
  left: CodePointPredicate,
  right: CodePointPredicate,
) => (c: CodePoint) => left(c) || right(c)

provide let (&.) = (
  left: CodePointPredicate,
  right: CodePointPredicate,
) => (c: CodePoint) => left(c) && right(c)

provide let exactly = (c: CodePoint) => (c2: CodePoint) => c == c2
provide let range = (start: CodePoint, end: CodePoint) => (c: CodePoint) => c >= start && c <= end

let _a = Char.code('a')
let _b = Char.code('b')
let _e = Char.code('e')
let _f = Char.code('f')
let _o = Char.code('o')
let _x = Char.code('x')
let _z = Char.code('z')

let _A = Char.code('A')
let _F = Char.code('F')
let _Z = Char.code('Z')

let _u = Char.code('u')
let _s = Char.code('s')
let _S = Char.code('S')
let _l = Char.code('l')
let _L = Char.code('L')

let _0 = Char.code('0')
let _1 = Char.code('1')
let _7 = Char.code('7')
let _9 = Char.code('9')
let _underscore = Char.code('_')
let _single_quote = Char.code('\'')
let _double_quote = Char.code('"')
let _backtick = Char.code('`')

// Single Character Reserved Symbols
let _right_bracket = Char.code(']')
let _left_bracket = Char.code('[')
let _right_paren = Char.code(')')
let _left_paren = Char.code('(')
let _right_brace = Char.code('}')
let _left_brace = Char.code('{')
let _comma = Char.code(',')

let reserved_symbols = Set.Immutable.fromList([
  _right_bracket,
  _left_bracket,
  _right_paren,
  _left_paren,
  _right_brace,
  _left_brace,
  _comma,
])

let is_reserved_symbol = (c: CodePoint) => Set.Immutable.contains(c, reserved_symbols)

// Multi Character Symbols
let _hyphen = Char.code('-')
let _dot = Char.code('.')
let _slash = Char.code('/')
let _backslash = Char.code('\\')
let _pipe = Char.code('|')
let _forward_slash = Char.code('/')
let _exclamation = Char.code('!')
let _question = Char.code('?')
let _at = Char.code('@')
let _hash = Char.code('#')
let _dollar = Char.code('$')
let _percent = Char.code('%')
let _caret = Char.code('^')
let _ampersand = Char.code('&')
let _asterisk = Char.code('*')
let _plus = Char.code('+')
let _minus = Char.code('-')
let _equals = Char.code('=')
let _less_than = Char.code('<')
let _greater_than = Char.code('>')
let _semicolon = Char.code(';')
let _colon = Char.code(':')
let _tilde = Char.code('~')

let multi_char_symbols = Set.Immutable.fromList([
  _hyphen,
  _dot,
  _slash,
  _backslash,
  _pipe,
  _forward_slash,
  _exclamation,
  _question,
  _at,
  _hash,
  _dollar,
  _percent,
  _caret,
  _ampersand,
  _asterisk,
  _plus,
  _minus,
  _equals,
  _less_than,
  _greater_than,
  _semicolon,
  _colon,
  _tilde,
])

let is_multi_char_symbol = (c: CodePoint) => Set.Immutable.contains(c, multi_char_symbols)

// whitespace
let _carriage_return = Char.code('\r')
let _sp = Char.code(' ')
let _tab = Char.code('\t')
let _newline = Char.code('\n')
let _nbsp = 0xA0
let _osm = 0x2000
let _enqd = 0x2001
let _emqd = 0x2002
let _ensp = 0x2003
let _emsp = 0x2004
let _tpesp = 0x2005
let _fpesp = 0x2006
let _spesp = 0x2007
let _fsp = 0x2008
let _psp = 0x2009
let _thsp = 0x200A
let _hsp = 0x202F
let _nnbsp = 0x205F
let _mssp = 0x3000

provide let is_whitespace = exactly(_tab)
  |. exactly(_newline)
  |. exactly(_carriage_return)
  |. exactly(_sp)
  |. exactly(_nbsp)

  // These codepoints are consecutive
  |. range(_osm, _thsp)
  // |. exactly(_osm)
  // |. exactly(_enqd)
  // |. exactly(_emqd)
  // |. exactly(_ensp)
  // |. exactly(_emsp)
  // |. exactly(_tpesp)
  // |. exactly(_fpesp)
  // |. exactly(_spesp)
  // |. exactly(_fsp)
  // |. exactly(_psp)
  // |. exactly(_thsp)

  |. exactly(_hsp)
  |. exactly(_nnbsp)
  |. exactly(_mssp)


provide let is_0 = exactly(_0)

provide let is_underscore = exactly(_underscore)
provide let is_hyphen = exactly(_hyphen)
provide let is_dot = exactly(_dot)
provide let is_slash = exactly(_slash)
provide let is_backslash = exactly(_backslash)
provide let is_pipe = exactly(_pipe)
provide let is_forward_slash = exactly(_forward_slash)
provide let is_right_bracket = exactly(_right_bracket)
provide let is_left_bracket = exactly(_left_bracket)
provide let is_right_paren = exactly(_right_paren)
provide let is_left_paren = exactly(_left_paren)
provide let is_right_brace = exactly(_right_brace)
provide let is_left_brace = exactly(_left_brace)
provide let is_single_quote = exactly(_single_quote)
provide let is_double_quote = exactly(_double_quote)
provide let is_backtick = exactly(_backtick)
provide let is_exclamation = exactly(_exclamation)
provide let is_question = exactly(_question)
provide let is_at = exactly(_at)
provide let is_hash = exactly(_hash)
provide let is_dollar = exactly(_dollar)
provide let is_percent = exactly(_percent)
provide let is_caret = exactly(_caret)
provide let is_ampersand = exactly(_ampersand)
provide let is_asterisk = exactly(_asterisk)
provide let is_plus = exactly(_plus)
provide let is_minus = exactly(_minus)
provide let is_equals = exactly(_equals)
provide let is_less_than = exactly(_less_than)
provide let is_greater_than = exactly(_greater_than)
provide let is_comma = exactly(_comma)
provide let is_semicolon = exactly(_semicolon)
provide let is_colon = exactly(_colon)
provide let is_tilde = exactly(_tilde)

provide let not = (pred: CodePointPredicate) => (c: CodePoint) => !pred(c)
provide let is_even = (c: CodePoint) => (c & 1) == 0
provide let is_odd = not(is_even)

let lower_set = Set.Immutable.fromList([
  0x61,
  0x62,
  0x63,
  0x64,
  0x65,
  0x66,
  0x67,
  0x68,
  0x69,
  0x6a,
  0x6b,
  0x6c,
  0x6d,
  0x6e,
  0x6f,
  0x70,
  0x71,
  0x72,
  0x73,
  0x74,
  0x75,
  0x76,
  0x77,
  0x78,
  0x79,
  0x7a,
  0xb5,
  0xdf,
  0xe0,
  0xe1,
  0xe2,
  0xe3,
  0xe4,
  0xe5,
  0xe6,
  0xe7,
  0xe8,
  0xe9,
  0xea,
  0xeb,
  0xec,
  0xed,
  0xee,
  0xef,
  0xf0,
  0xf1,
  0xf2,
  0xf3,
  0xf4,
  0xf5,
  0xf6,
  0xf8,
  0xf9,
  0xfa,
  0xfb,
  0xfc,
  0xfd,
  0xfe,
  0xff,
  0x101,
  0x103,
  0x105,
  0x107,
  0x109,
  0x10b,
  0x10d,
  0x10f,
  0x111,
  0x113,
  0x115,
  0x117,
  0x119,
  0x11b,
  0x11d,
  0x11f,
  0x121,
  0x123,
  0x125,
  0x127,
  0x129,
  0x12b,
  0x12d,
  0x12f,
  0x131,
  0x133,
  0x135,
  0x137,
  0x138,
  0x13a,
  0x13c,
  0x13e,
  0x140,
  0x142,
  0x144,
  0x146,
  0x148,
  0x149,
  0x14b,
  0x14d,
  0x14f,
  0x151,
  0x153,
  0x155,
  0x157,
  0x159,
  0x15b,
  0x15d,
  0x15f,
  0x161,
  0x163,
  0x165,
  0x167,
  0x169,
  0x16b,
  0x16d,
  0x16f,
  0x171,
  0x173,
  0x175,
  0x177,
  0x17a,
  0x17c,
  0x17e,
  0x17f,
  0x180,
  0x183,
  0x185,
  0x188,
  0x18c,
  0x18d,
  0x192,
  0x195,
  0x199,
  0x19a,
  0x19b,
  0x19e,
  0x1a1,
  0x1a3,
  0x1a5,
  0x1a8,
  0x1aa,
  0x1ab,
  0x1ad,
  0x1b0,
  0x1b4,
  0x1b6,
  0x1b9,
  0x1ba,
  0x1bd,
  0x1be,
  0x1bf,
  0x1c6,
  0x1c9,
  0x1cc,
  0x1ce,
  0x1d0,
  0x1d2,
  0x1d4,
  0x1d6,
  0x1d8,
  0x1da,
  0x1dc,
  0x1dd,
  0x1df,
  0x1e1,
  0x1e3,
  0x1e5,
  0x1e7,
  0x1e9,
  0x1eb,
  0x1ed,
  0x1ef,
  0x1f0,
  0x1f3,
  0x1f5,
  0x1f9,
  0x1fb,
  0x1fd,
  0x1ff,
  0x201,
  0x203,
  0x205,
  0x207,
  0x209,
  0x20b,
  0x20d,
  0x20f,
  0x211,
  0x213,
  0x215,
  0x217,
  0x219,
  0x21b,
  0x21d,
  0x21f,
  0x221,
  0x223,
  0x225,
  0x227,
  0x229,
  0x22b,
  0x22d,
  0x22f,
  0x231,
  0x233,
  0x234,
  0x235,
  0x236,
  0x237,
  0x238,
  0x239,
  0x23c,
  0x23f,
  0x240,
  0x242,
  0x247,
  0x249,
  0x24b,
  0x24d,
  0x24f,
  0x250,
  0x251,
  0x252,
  0x253,
  0x254,
  0x255,
  0x256,
  0x257,
  0x258,
  0x259,
  0x25a,
  0x25b,
  0x25c,
  0x25d,
  0x25e,
  0x25f,
  0x260,
  0x261,
  0x262,
  0x263,
  0x264,
  0x265,
  0x266,
  0x267,
  0x268,
  0x269,
  0x26a,
  0x26b,
  0x26c,
  0x26d,
  0x26e,
  0x26f,
  0x270,
  0x271,
  0x272,
  0x273,
  0x274,
  0x275,
  0x276,
  0x277,
  0x278,
  0x279,
  0x27a,
  0x27b,
  0x27c,
  0x27d,
  0x27e,
  0x27f,
  0x280,
  0x281,
  0x282,
  0x283,
  0x284,
  0x285,
  0x286,
  0x287,
  0x288,
  0x289,
  0x28a,
  0x28b,
  0x28c,
  0x28d,
  0x28e,
  0x28f,
  0x290,
  0x291,
  0x292,
  0x293,
  0x295,
  0x296,
  0x297,
  0x298,
  0x299,
  0x29a,
  0x29b,
  0x29c,
  0x29d,
  0x29e,
  0x29f,
  0x2a0,
  0x2a1,
  0x2a2,
  0x2a3,
  0x2a4,
  0x2a5,
  0x2a6,
  0x2a7,
  0x2a8,
  0x2a9,
  0x2aa,
  0x2ab,
  0x2ac,
  0x2ad,
  0x2ae,
  0x2af,
  0x371,
  0x373,
  0x377,
  0x37b,
  0x37c,
  0x37d,
  0x390,
  0x3ac,
  0x3ad,
  0x3ae,
  0x3af,
  0x3b0,
  0x3b1,
  0x3b2,
  0x3b3,
  0x3b4,
  0x3b5,
  0x3b6,
  0x3b7,
  0x3b8,
  0x3b9,
  0x3ba,
  0x3bb,
  0x3bc,
  0x3bd,
  0x3be,
  0x3bf,
  0x3c0,
  0x3c1,
  0x3c2,
  0x3c3,
  0x3c4,
  0x3c5,
  0x3c6,
  0x3c7,
  0x3c8,
  0x3c9,
  0x3ca,
  0x3cb,
  0x3cc,
  0x3cd,
  0x3ce,
  0x3d0,
  0x3d1,
  0x3d5,
  0x3d6,
  0x3d7,
  0x3d9,
  0x3db,
  0x3dd,
  0x3df,
  0x3e1,
  0x3e3,
  0x3e5,
  0x3e7,
  0x3e9,
  0x3eb,
  0x3ed,
  0x3ef,
  0x3f0,
  0x3f1,
  0x3f2,
  0x3f3,
  0x3f5,
  0x3f8,
  0x3fb,
  0x3fc,
  0x430,
  0x431,
  0x432,
  0x433,
  0x434,
  0x435,
  0x436,
  0x437,
  0x438,
  0x439,
  0x43a,
  0x43b,
  0x43c,
  0x43d,
  0x43e,
  0x43f,
  0x440,
  0x441,
  0x442,
  0x443,
  0x444,
  0x445,
  0x446,
  0x447,
  0x448,
  0x449,
  0x44a,
  0x44b,
  0x44c,
  0x44d,
  0x44e,
  0x44f,
  0x450,
  0x451,
  0x452,
  0x453,
  0x454,
  0x455,
  0x456,
  0x457,
  0x458,
  0x459,
  0x45a,
  0x45b,
  0x45c,
  0x45d,
  0x45e,
  0x45f,
  0x461,
  0x463,
  0x465,
  0x467,
  0x469,
  0x46b,
  0x46d,
  0x46f,
  0x471,
  0x473,
  0x475,
  0x477,
  0x479,
  0x47b,
  0x47d,
  0x47f,
  0x481,
  0x48b,
  0x48d,
  0x48f,
  0x491,
  0x493,
  0x495,
  0x497,
  0x499,
  0x49b,
  0x49d,
  0x49f,
  0x4a1,
  0x4a3,
  0x4a5,
  0x4a7,
  0x4a9,
  0x4ab,
  0x4ad,
  0x4af,
  0x4b1,
  0x4b3,
  0x4b5,
  0x4b7,
  0x4b9,
  0x4bb,
  0x4bd,
  0x4bf,
  0x4c2,
  0x4c4,
  0x4c6,
  0x4c8,
  0x4ca,
  0x4cc,
  0x4ce,
  0x4cf,
  0x4d1,
  0x4d3,
  0x4d5,
  0x4d7,
  0x4d9,
  0x4db,
  0x4dd,
  0x4df,
  0x4e1,
  0x4e3,
  0x4e5,
  0x4e7,
  0x4e9,
  0x4eb,
  0x4ed,
  0x4ef,
  0x4f1,
  0x4f3,
  0x4f5,
  0x4f7,
  0x4f9,
  0x4fb,
  0x4fd,
  0x4ff,
  0x501,
  0x503,
  0x505,
  0x507,
  0x509,
  0x50b,
  0x50d,
  0x50f,
  0x511,
  0x513,
  0x515,
  0x517,
  0x519,
  0x51b,
  0x51d,
  0x51f,
  0x521,
  0x523,
  0x525,
  0x527,
  0x529,
  0x52b,
  0x52d,
  0x52f,
  0x560,
  0x561,
  0x562,
  0x563,
  0x564,
  0x565,
  0x566,
  0x567,
  0x568,
  0x569,
  0x56a,
  0x56b,
  0x56c,
  0x56d,
  0x56e,
  0x56f,
  0x570,
  0x571,
  0x572,
  0x573,
  0x574,
  0x575,
  0x576,
  0x577,
  0x578,
  0x579,
  0x57a,
  0x57b,
  0x57c,
  0x57d,
  0x57e,
  0x57f,
  0x580,
  0x581,
  0x582,
  0x583,
  0x584,
  0x585,
  0x586,
  0x587,
  0x588,
  0x10d0,
  0x10d1,
  0x10d2,
  0x10d3,
  0x10d4,
  0x10d5,
  0x10d6,
  0x10d7,
  0x10d8,
  0x10d9,
  0x10da,
  0x10db,
  0x10dc,
  0x10dd,
  0x10de,
  0x10df,
  0x10e0,
  0x10e1,
  0x10e2,
  0x10e3,
  0x10e4,
  0x10e5,
  0x10e6,
  0x10e7,
  0x10e8,
  0x10e9,
  0x10ea,
  0x10eb,
  0x10ec,
  0x10ed,
  0x10ee,
  0x10ef,
  0x10f0,
  0x10f1,
  0x10f2,
  0x10f3,
  0x10f4,
  0x10f5,
  0x10f6,
  0x10f7,
  0x10f8,
  0x10f9,
  0x10fa,
  0x10fd,
  0x10fe,
  0x10ff,
  0x13f8,
  0x13f9,
  0x13fa,
  0x13fb,
  0x13fc,
  0x13fd,
  0x1c80,
  0x1c81,
  0x1c82,
  0x1c83,
  0x1c84,
  0x1c85,
  0x1c86,
  0x1c87,
  0x1c88,
  0x1c8a,
  0x1d00,
  0x1d01,
  0x1d02,
  0x1d03,
  0x1d04,
  0x1d05,
  0x1d06,
  0x1d07,
  0x1d08,
  0x1d09,
  0x1d0a,
  0x1d0b,
  0x1d0c,
  0x1d0d,
  0x1d0e,
  0x1d0f,
  0x1d10,
  0x1d11,
  0x1d12,
  0x1d13,
  0x1d14,
  0x1d15,
  0x1d16,
  0x1d17,
  0x1d18,
  0x1d19,
  0x1d1a,
  0x1d1b,
  0x1d1c,
  0x1d1d,
  0x1d1e,
  0x1d1f,
  0x1d20,
  0x1d21,
  0x1d22,
  0x1d23,
  0x1d24,
  0x1d25,
  0x1d26,
  0x1d27,
  0x1d28,
  0x1d29,
  0x1d2a,
  0x1d2b,
  0x1d6b,
  0x1d6c,
  0x1d6d,
  0x1d6e,
  0x1d6f,
  0x1d70,
  0x1d71,
  0x1d72,
  0x1d73,
  0x1d74,
  0x1d75,
  0x1d76,
  0x1d77,
  0x1d79,
  0x1d7a,
  0x1d7b,
  0x1d7c,
  0x1d7d,
  0x1d7e,
  0x1d7f,
  0x1d80,
  0x1d81,
  0x1d82,
  0x1d83,
  0x1d84,
  0x1d85,
  0x1d86,
  0x1d87,
  0x1d88,
  0x1d89,
  0x1d8a,
  0x1d8b,
  0x1d8c,
  0x1d8d,
  0x1d8e,
  0x1d8f,
  0x1d90,
  0x1d91,
  0x1d92,
  0x1d93,
  0x1d94,
  0x1d95,
  0x1d96,
  0x1d97,
  0x1d98,
  0x1d99,
  0x1d9a,
  0x1e01,
  0x1e03,
  0x1e05,
  0x1e07,
  0x1e09,
  0x1e0b,
  0x1e0d,
  0x1e0f,
  0x1e11,
  0x1e13,
  0x1e15,
  0x1e17,
  0x1e19,
  0x1e1b,
  0x1e1d,
  0x1e1f,
  0x1e21,
  0x1e23,
  0x1e25,
  0x1e27,
  0x1e29,
  0x1e2b,
  0x1e2d,
  0x1e2f,
  0x1e31,
  0x1e33,
  0x1e35,
  0x1e37,
  0x1e39,
  0x1e3b,
  0x1e3d,
  0x1e3f,
  0x1e41,
  0x1e43,
  0x1e45,
  0x1e47,
  0x1e49,
  0x1e4b,
  0x1e4d,
  0x1e4f,
  0x1e51,
  0x1e53,
  0x1e55,
  0x1e57,
  0x1e59,
  0x1e5b,
  0x1e5d,
  0x1e5f,
  0x1e61,
  0x1e63,
  0x1e65,
  0x1e67,
  0x1e69,
  0x1e6b,
  0x1e6d,
  0x1e6f,
  0x1e71,
  0x1e73,
  0x1e75,
  0x1e77,
  0x1e79,
  0x1e7b,
  0x1e7d,
  0x1e7f,
  0x1e81,
  0x1e83,
  0x1e85,
  0x1e87,
  0x1e89,
  0x1e8b,
  0x1e8d,
  0x1e8f,
  0x1e91,
  0x1e93,
  0x1e95,
  0x1e96,
  0x1e97,
  0x1e98,
  0x1e99,
  0x1e9a,
  0x1e9b,
  0x1e9c,
  0x1e9d,
  0x1e9f,
  0x1ea1,
  0x1ea3,
  0x1ea5,
  0x1ea7,
  0x1ea9,
  0x1eab,
  0x1ead,
  0x1eaf,
  0x1eb1,
  0x1eb3,
  0x1eb5,
  0x1eb7,
  0x1eb9,
  0x1ebb,
  0x1ebd,
  0x1ebf,
  0x1ec1,
  0x1ec3,
  0x1ec5,
  0x1ec7,
  0x1ec9,
  0x1ecb,
  0x1ecd,
  0x1ecf,
  0x1ed1,
  0x1ed3,
  0x1ed5,
  0x1ed7,
  0x1ed9,
  0x1edb,
  0x1edd,
  0x1edf,
  0x1ee1,
  0x1ee3,
  0x1ee5,
  0x1ee7,
  0x1ee9,
  0x1eeb,
  0x1eed,
  0x1eef,
  0x1ef1,
  0x1ef3,
  0x1ef5,
  0x1ef7,
  0x1ef9,
  0x1efb,
  0x1efd,
  0x1eff,
  0x1f00,
  0x1f01,
  0x1f02,
  0x1f03,
  0x1f04,
  0x1f05,
  0x1f06,
  0x1f07,
  0x1f10,
  0x1f11,
  0x1f12,
  0x1f13,
  0x1f14,
  0x1f15,
  0x1f20,
  0x1f21,
  0x1f22,
  0x1f23,
  0x1f24,
  0x1f25,
  0x1f26,
  0x1f27,
  0x1f30,
  0x1f31,
  0x1f32,
  0x1f33,
  0x1f34,
  0x1f35,
  0x1f36,
  0x1f37,
  0x1f40,
  0x1f41,
  0x1f42,
  0x1f43,
  0x1f44,
  0x1f45,
  0x1f50,
  0x1f51,
  0x1f52,
  0x1f53,
  0x1f54,
  0x1f55,
  0x1f56,
  0x1f57,
  0x1f60,
  0x1f61,
  0x1f62,
  0x1f63,
  0x1f64,
  0x1f65,
  0x1f66,
  0x1f67,
  0x1f70,
  0x1f71,
  0x1f72,
  0x1f73,
  0x1f74,
  0x1f75,
  0x1f76,
  0x1f77,
  0x1f78,
  0x1f79,
  0x1f7a,
  0x1f7b,
  0x1f7c,
  0x1f7d,
  0x1f80,
  0x1f81,
  0x1f82,
  0x1f83,
  0x1f84,
  0x1f85,
  0x1f86,
  0x1f87,
  0x1f90,
  0x1f91,
  0x1f92,
  0x1f93,
  0x1f94,
  0x1f95,
  0x1f96,
  0x1f97,
  0x1fa0,
  0x1fa1,
  0x1fa2,
  0x1fa3,
  0x1fa4,
  0x1fa5,
  0x1fa6,
  0x1fa7,
  0x1fb0,
  0x1fb1,
  0x1fb2,
  0x1fb3,
  0x1fb4,
  0x1fb6,
  0x1fb7,
  0x1fbe,
  0x1fc2,
  0x1fc3,
  0x1fc4,
  0x1fc6,
  0x1fc7,
  0x1fd0,
  0x1fd1,
  0x1fd2,
  0x1fd3,
  0x1fd6,
  0x1fd7,
  0x1fe0,
  0x1fe1,
  0x1fe2,
  0x1fe3,
  0x1fe4,
  0x1fe5,
  0x1fe6,
  0x1fe7,
  0x1ff2,
  0x1ff3,
  0x1ff4,
  0x1ff6,
  0x1ff7,
  0x210a,
  0x210e,
  0x210f,
  0x2113,
  0x212f,
  0x2134,
  0x2139,
  0x213c,
  0x213d,
  0x2146,
  0x2147,
  0x2148,
  0x2149,
  0x214e,
  0x2184,
  0x2c30,
  0x2c31,
  0x2c32,
  0x2c33,
  0x2c34,
  0x2c35,
  0x2c36,
  0x2c37,
  0x2c38,
  0x2c39,
  0x2c3a,
  0x2c3b,
  0x2c3c,
  0x2c3d,
  0x2c3e,
  0x2c3f,
  0x2c40,
  0x2c41,
  0x2c42,
  0x2c43,
  0x2c44,
  0x2c45,
  0x2c46,
  0x2c47,
  0x2c48,
  0x2c49,
  0x2c4a,
  0x2c4b,
  0x2c4c,
  0x2c4d,
  0x2c4e,
  0x2c4f,
  0x2c50,
  0x2c51,
  0x2c52,
  0x2c53,
  0x2c54,
  0x2c55,
  0x2c56,
  0x2c57,
  0x2c58,
  0x2c59,
  0x2c5a,
  0x2c5b,
  0x2c5c,
  0x2c5d,
  0x2c5e,
  0x2c5f,
  0x2c61,
  0x2c65,
  0x2c66,
  0x2c68,
  0x2c6a,
  0x2c6c,
  0x2c71,
  0x2c73,
  0x2c74,
  0x2c76,
  0x2c77,
  0x2c78,
  0x2c79,
  0x2c7a,
  0x2c7b,
  0x2c81,
  0x2c83,
  0x2c85,
  0x2c87,
  0x2c89,
  0x2c8b,
  0x2c8d,
  0x2c8f,
  0x2c91,
  0x2c93,
  0x2c95,
  0x2c97,
  0x2c99,
  0x2c9b,
  0x2c9d,
  0x2c9f,
  0x2ca1,
  0x2ca3,
  0x2ca5,
  0x2ca7,
  0x2ca9,
  0x2cab,
  0x2cad,
  0x2caf,
  0x2cb1,
  0x2cb3,
  0x2cb5,
  0x2cb7,
  0x2cb9,
  0x2cbb,
  0x2cbd,
  0x2cbf,
  0x2cc1,
  0x2cc3,
  0x2cc5,
  0x2cc7,
  0x2cc9,
  0x2ccb,
  0x2ccd,
  0x2ccf,
  0x2cd1,
  0x2cd3,
  0x2cd5,
  0x2cd7,
  0x2cd9,
  0x2cdb,
  0x2cdd,
  0x2cdf,
  0x2ce1,
  0x2ce3,
  0x2ce4,
  0x2cec,
  0x2cee,
  0x2cf3,
  0x2d00,
  0x2d01,
  0x2d02,
  0x2d03,
  0x2d04,
  0x2d05,
  0x2d06,
  0x2d07,
  0x2d08,
  0x2d09,
  0x2d0a,
  0x2d0b,
  0x2d0c,
  0x2d0d,
  0x2d0e,
  0x2d0f,
  0x2d10,
  0x2d11,
  0x2d12,
  0x2d13,
  0x2d14,
  0x2d15,
  0x2d16,
  0x2d17,
  0x2d18,
  0x2d19,
  0x2d1a,
  0x2d1b,
  0x2d1c,
  0x2d1d,
  0x2d1e,
  0x2d1f,
  0x2d20,
  0x2d21,
  0x2d22,
  0x2d23,
  0x2d24,
  0x2d25,
  0x2d27,
  0x2d2d,
  0xa641,
  0xa643,
  0xa645,
  0xa647,
  0xa649,
  0xa64b,
  0xa64d,
  0xa64f,
  0xa651,
  0xa653,
  0xa655,
  0xa657,
  0xa659,
  0xa65b,
  0xa65d,
  0xa65f,
  0xa661,
  0xa663,
  0xa665,
  0xa667,
  0xa669,
  0xa66b,
  0xa66d,
  0xa681,
  0xa683,
  0xa685,
  0xa687,
  0xa689,
  0xa68b,
  0xa68d,
  0xa68f,
  0xa691,
  0xa693,
  0xa695,
  0xa697,
  0xa699,
  0xa69b,
  0xa723,
  0xa725,
  0xa727,
  0xa729,
  0xa72b,
  0xa72d,
  0xa72f,
  0xa730,
  0xa731,
  0xa733,
  0xa735,
  0xa737,
  0xa739,
  0xa73b,
  0xa73d,
  0xa73f,
  0xa741,
  0xa743,
  0xa745,
  0xa747,
  0xa749,
  0xa74b,
  0xa74d,
  0xa74f,
  0xa751,
  0xa753,
  0xa755,
  0xa757,
  0xa759,
  0xa75b,
  0xa75d,
  0xa75f,
  0xa761,
  0xa763,
  0xa765,
  0xa767,
  0xa769,
  0xa76b,
  0xa76d,
  0xa76f,
  0xa771,
  0xa772,
  0xa773,
  0xa774,
  0xa775,
  0xa776,
  0xa777,
  0xa778,
  0xa77a,
  0xa77c,
  0xa77f,
  0xa781,
  0xa783,
  0xa785,
  0xa787,
  0xa78c,
  0xa78e,
  0xa791,
  0xa793,
  0xa794,
  0xa795,
  0xa797,
  0xa799,
  0xa79b,
  0xa79d,
  0xa79f,
  0xa7a1,
  0xa7a3,
  0xa7a5,
  0xa7a7,
  0xa7a9,
  0xa7af,
  0xa7b5,
  0xa7b7,
  0xa7b9,
  0xa7bb,
  0xa7bd,
  0xa7bf,
  0xa7c1,
  0xa7c3,
  0xa7c8,
  0xa7ca,
  0xa7cd,
  0xa7d1,
  0xa7d3,
  0xa7d5,
  0xa7d7,
  0xa7d9,
  0xa7db,
  0xa7f6,
  0xa7fa,
  0xab30,
  0xab31,
  0xab32,
  0xab33,
  0xab34,
  0xab35,
  0xab36,
  0xab37,
  0xab38,
  0xab39,
  0xab3a,
  0xab3b,
  0xab3c,
  0xab3d,
  0xab3e,
  0xab3f,
  0xab40,
  0xab41,
  0xab42,
  0xab43,
  0xab44,
  0xab45,
  0xab46,
  0xab47,
  0xab48,
  0xab49,
  0xab4a,
  0xab4b,
  0xab4c,
  0xab4d,
  0xab4e,
  0xab4f,
  0xab50,
  0xab51,
  0xab52,
  0xab53,
  0xab54,
  0xab55,
  0xab56,
  0xab57,
  0xab58,
  0xab59,
  0xab5a,
  0xab60,
  0xab61,
  0xab62,
  0xab63,
  0xab64,
  0xab65,
  0xab66,
  0xab67,
  0xab68,
  0xab70,
  0xab71,
  0xab72,
  0xab73,
  0xab74,
  0xab75,
  0xab76,
  0xab77,
  0xab78,
  0xab79,
  0xab7a,
  0xab7b,
  0xab7c,
  0xab7d,
  0xab7e,
  0xab7f,
  0xab80,
  0xab81,
  0xab82,
  0xab83,
  0xab84,
  0xab85,
  0xab86,
  0xab87,
  0xab88,
  0xab89,
  0xab8a,
  0xab8b,
  0xab8c,
  0xab8d,
  0xab8e,
  0xab8f,
  0xab90,
  0xab91,
  0xab92,
  0xab93,
  0xab94,
  0xab95,
  0xab96,
  0xab97,
  0xab98,
  0xab99,
  0xab9a,
  0xab9b,
  0xab9c,
  0xab9d,
  0xab9e,
  0xab9f,
  0xaba0,
  0xaba1,
  0xaba2,
  0xaba3,
  0xaba4,
  0xaba5,
  0xaba6,
  0xaba7,
  0xaba8,
  0xaba9,
  0xabaa,
  0xabab,
  0xabac,
  0xabad,
  0xabae,
  0xabaf,
  0xabb0,
  0xabb1,
  0xabb2,
  0xabb3,
  0xabb4,
  0xabb5,
  0xabb6,
  0xabb7,
  0xabb8,
  0xabb9,
  0xabba,
  0xabbb,
  0xabbc,
  0xabbd,
  0xabbe,
  0xabbf,
  0xfb00,
  0xfb01,
  0xfb02,
  0xfb03,
  0xfb04,
  0xfb05,
  0xfb06,
  0xfb13,
  0xfb14,
  0xfb15,
  0xfb16,
  0xfb17,
  0xff41,
  0xff42,
  0xff43,
  0xff44,
  0xff45,
  0xff46,
  0xff47,
  0xff48,
  0xff49,
  0xff4a,
  0xff4b,
  0xff4c,
  0xff4d,
  0xff4e,
  0xff4f,
  0xff50,
  0xff51,
  0xff52,
  0xff53,
  0xff54,
  0xff55,
  0xff56,
  0xff57,
  0xff58,
  0xff59,
  0xff5a,
  0x10428,
  0x10429,
  0x1042a,
  0x1042b,
  0x1042c,
  0x1042d,
  0x1042e,
  0x1042f,
  0x10430,
  0x10431,
  0x10432,
  0x10433,
  0x10434,
  0x10435,
  0x10436,
  0x10437,
  0x10438,
  0x10439,
  0x1043a,
  0x1043b,
  0x1043c,
  0x1043d,
  0x1043e,
  0x1043f,
  0x10440,
  0x10441,
  0x10442,
  0x10443,
  0x10444,
  0x10445,
  0x10446,
  0x10447,
  0x10448,
  0x10449,
  0x1044a,
  0x1044b,
  0x1044c,
  0x1044d,
  0x1044e,
  0x1044f,
  0x104d8,
  0x104d9,
  0x104da,
  0x104db,
  0x104dc,
  0x104dd,
  0x104de,
  0x104df,
  0x104e0,
  0x104e1,
  0x104e2,
  0x104e3,
  0x104e4,
  0x104e5,
  0x104e6,
  0x104e7,
  0x104e8,
  0x104e9,
  0x104ea,
  0x104eb,
  0x104ec,
  0x104ed,
  0x104ee,
  0x104ef,
  0x104f0,
  0x104f1,
  0x104f2,
  0x104f3,
  0x104f4,
  0x104f5,
  0x104f6,
  0x104f7,
  0x104f8,
  0x104f9,
  0x104fa,
  0x104fb,
  0x10597,
  0x10598,
  0x10599,
  0x1059a,
  0x1059b,
  0x1059c,
  0x1059d,
  0x1059e,
  0x1059f,
  0x105a0,
  0x105a1,
  0x105a3,
  0x105a4,
  0x105a5,
  0x105a6,
  0x105a7,
  0x105a8,
  0x105a9,
  0x105aa,
  0x105ab,
  0x105ac,
  0x105ad,
  0x105ae,
  0x105af,
  0x105b0,
  0x105b1,
  0x105b3,
  0x105b4,
  0x105b5,
  0x105b6,
  0x105b7,
  0x105b8,
  0x105b9,
  0x105bb,
  0x105bc,
  0x10cc0,
  0x10cc1,
  0x10cc2,
  0x10cc3,
  0x10cc4,
  0x10cc5,
  0x10cc6,
  0x10cc7,
  0x10cc8,
  0x10cc9,
  0x10cca,
  0x10ccb,
  0x10ccc,
  0x10ccd,
  0x10cce,
  0x10ccf,
  0x10cd0,
  0x10cd1,
  0x10cd2,
  0x10cd3,
  0x10cd4,
  0x10cd5,
  0x10cd6,
  0x10cd7,
  0x10cd8,
  0x10cd9,
  0x10cda,
  0x10cdb,
  0x10cdc,
  0x10cdd,
  0x10cde,
  0x10cdf,
  0x10ce0,
  0x10ce1,
  0x10ce2,
  0x10ce3,
  0x10ce4,
  0x10ce5,
  0x10ce6,
  0x10ce7,
  0x10ce8,
  0x10ce9,
  0x10cea,
  0x10ceb,
  0x10cec,
  0x10ced,
  0x10cee,
  0x10cef,
  0x10cf0,
  0x10cf1,
  0x10cf2,
  0x10d70,
  0x10d71,
  0x10d72,
  0x10d73,
  0x10d74,
  0x10d75,
  0x10d76,
  0x10d77,
  0x10d78,
  0x10d79,
  0x10d7a,
  0x10d7b,
  0x10d7c,
  0x10d7d,
  0x10d7e,
  0x10d7f,
  0x10d80,
  0x10d81,
  0x10d82,
  0x10d83,
  0x10d84,
  0x10d85,
  0x118c0,
  0x118c1,
  0x118c2,
  0x118c3,
  0x118c4,
  0x118c5,
  0x118c6,
  0x118c7,
  0x118c8,
  0x118c9,
  0x118ca,
  0x118cb,
  0x118cc,
  0x118cd,
  0x118ce,
  0x118cf,
  0x118d0,
  0x118d1,
  0x118d2,
  0x118d3,
  0x118d4,
  0x118d5,
  0x118d6,
  0x118d7,
  0x118d8,
  0x118d9,
  0x118da,
  0x118db,
  0x118dc,
  0x118dd,
  0x118de,
  0x118df,
  0x16e60,
  0x16e61,
  0x16e62,
  0x16e63,
  0x16e64,
  0x16e65,
  0x16e66,
  0x16e67,
  0x16e68,
  0x16e69,
  0x16e6a,
  0x16e6b,
  0x16e6c,
  0x16e6d,
  0x16e6e,
  0x16e6f,
  0x16e70,
  0x16e71,
  0x16e72,
  0x16e73,
  0x16e74,
  0x16e75,
  0x16e76,
  0x16e77,
  0x16e78,
  0x16e79,
  0x16e7a,
  0x16e7b,
  0x16e7c,
  0x16e7d,
  0x16e7e,
  0x16e7f,
  0x1d41a,
  0x1d41b,
  0x1d41c,
  0x1d41d,
  0x1d41e,
  0x1d41f,
  0x1d420,
  0x1d421,
  0x1d422,
  0x1d423,
  0x1d424,
  0x1d425,
  0x1d426,
  0x1d427,
  0x1d428,
  0x1d429,
  0x1d42a,
  0x1d42b,
  0x1d42c,
  0x1d42d,
  0x1d42e,
  0x1d42f,
  0x1d430,
  0x1d431,
  0x1d432,
  0x1d433,
  0x1d44e,
  0x1d44f,
  0x1d450,
  0x1d451,
  0x1d452,
  0x1d453,
  0x1d454,
  0x1d456,
  0x1d457,
  0x1d458,
  0x1d459,
  0x1d45a,
  0x1d45b,
  0x1d45c,
  0x1d45d,
  0x1d45e,
  0x1d45f,
  0x1d460,
  0x1d461,
  0x1d462,
  0x1d463,
  0x1d464,
  0x1d465,
  0x1d466,
  0x1d467,
  0x1d482,
  0x1d483,
  0x1d484,
  0x1d485,
  0x1d486,
  0x1d487,
  0x1d488,
  0x1d489,
  0x1d48a,
  0x1d48b,
  0x1d48c,
  0x1d48d,
  0x1d48e,
  0x1d48f,
  0x1d490,
  0x1d491,
  0x1d492,
  0x1d493,
  0x1d494,
  0x1d495,
  0x1d496,
  0x1d497,
  0x1d498,
  0x1d499,
  0x1d49a,
  0x1d49b,
  0x1d4b6,
  0x1d4b7,
  0x1d4b8,
  0x1d4b9,
  0x1d4bb,
  0x1d4bd,
  0x1d4be,
  0x1d4bf,
  0x1d4c0,
  0x1d4c1,
  0x1d4c2,
  0x1d4c3,
  0x1d4c5,
  0x1d4c6,
  0x1d4c7,
  0x1d4c8,
  0x1d4c9,
  0x1d4ca,
  0x1d4cb,
  0x1d4cc,
  0x1d4cd,
  0x1d4ce,
  0x1d4cf,
  0x1d4ea,
  0x1d4eb,
  0x1d4ec,
  0x1d4ed,
  0x1d4ee,
  0x1d4ef,
  0x1d4f0,
  0x1d4f1,
  0x1d4f2,
  0x1d4f3,
  0x1d4f4,
  0x1d4f5,
  0x1d4f6,
  0x1d4f7,
  0x1d4f8,
  0x1d4f9,
  0x1d4fa,
  0x1d4fb,
  0x1d4fc,
  0x1d4fd,
  0x1d4fe,
  0x1d4ff,
  0x1d500,
  0x1d501,
  0x1d502,
  0x1d503,
  0x1d51e,
  0x1d51f,
  0x1d520,
  0x1d521,
  0x1d522,
  0x1d523,
  0x1d524,
  0x1d525,
  0x1d526,
  0x1d527,
  0x1d528,
  0x1d529,
  0x1d52a,
  0x1d52b,
  0x1d52c,
  0x1d52d,
  0x1d52e,
  0x1d52f,
  0x1d530,
  0x1d531,
  0x1d532,
  0x1d533,
  0x1d534,
  0x1d535,
  0x1d536,
  0x1d537,
  0x1d552,
  0x1d553,
  0x1d554,
  0x1d555,
  0x1d556,
  0x1d557,
  0x1d558,
  0x1d559,
  0x1d55a,
  0x1d55b,
  0x1d55c,
  0x1d55d,
  0x1d55e,
  0x1d55f,
  0x1d560,
  0x1d561,
  0x1d562,
  0x1d563,
  0x1d564,
  0x1d565,
  0x1d566,
  0x1d567,
  0x1d568,
  0x1d569,
  0x1d56a,
  0x1d56b,
  0x1d586,
  0x1d587,
  0x1d588,
  0x1d589,
  0x1d58a,
  0x1d58b,
  0x1d58c,
  0x1d58d,
  0x1d58e,
  0x1d58f,
  0x1d590,
  0x1d591,
  0x1d592,
  0x1d593,
  0x1d594,
  0x1d595,
  0x1d596,
  0x1d597,
  0x1d598,
  0x1d599,
  0x1d59a,
  0x1d59b,
  0x1d59c,
  0x1d59d,
  0x1d59e,
  0x1d59f,
  0x1d5ba,
  0x1d5bb,
  0x1d5bc,
  0x1d5bd,
  0x1d5be,
  0x1d5bf,
  0x1d5c0,
  0x1d5c1,
  0x1d5c2,
  0x1d5c3,
  0x1d5c4,
  0x1d5c5,
  0x1d5c6,
  0x1d5c7,
  0x1d5c8,
  0x1d5c9,
  0x1d5ca,
  0x1d5cb,
  0x1d5cc,
  0x1d5cd,
  0x1d5ce,
  0x1d5cf,
  0x1d5d0,
  0x1d5d1,
  0x1d5d2,
  0x1d5d3,
  0x1d5ee,
  0x1d5ef,
  0x1d5f0,
  0x1d5f1,
  0x1d5f2,
  0x1d5f3,
  0x1d5f4,
  0x1d5f5,
  0x1d5f6,
  0x1d5f7,
  0x1d5f8,
  0x1d5f9,
  0x1d5fa,
  0x1d5fb,
  0x1d5fc,
  0x1d5fd,
  0x1d5fe,
  0x1d5ff,
  0x1d600,
  0x1d601,
  0x1d602,
  0x1d603,
  0x1d604,
  0x1d605,
  0x1d606,
  0x1d607,
  0x1d622,
  0x1d623,
  0x1d624,
  0x1d625,
  0x1d626,
  0x1d627,
  0x1d628,
  0x1d629,
  0x1d62a,
  0x1d62b,
  0x1d62c,
  0x1d62d,
  0x1d62e,
  0x1d62f,
  0x1d630,
  0x1d631,
  0x1d632,
  0x1d633,
  0x1d634,
  0x1d635,
  0x1d636,
  0x1d637,
  0x1d638,
  0x1d639,
  0x1d63a,
  0x1d63b,
  0x1d656,
  0x1d657,
  0x1d658,
  0x1d659,
  0x1d65a,
  0x1d65b,
  0x1d65c,
  0x1d65d,
  0x1d65e,
  0x1d65f,
  0x1d660,
  0x1d661,
  0x1d662,
  0x1d663,
  0x1d664,
  0x1d665,
  0x1d666,
  0x1d667,
  0x1d668,
  0x1d669,
  0x1d66a,
  0x1d66b,
  0x1d66c,
  0x1d66d,
  0x1d66e,
  0x1d66f,
  0x1d68a,
  0x1d68b,
  0x1d68c,
  0x1d68d,
  0x1d68e,
  0x1d68f,
  0x1d690,
  0x1d691,
  0x1d692,
  0x1d693,
  0x1d694,
  0x1d695,
  0x1d696,
  0x1d697,
  0x1d698,
  0x1d699,
  0x1d69a,
  0x1d69b,
  0x1d69c,
  0x1d69d,
  0x1d69e,
  0x1d69f,
  0x1d6a0,
  0x1d6a1,
  0x1d6a2,
  0x1d6a3,
  0x1d6a4,
  0x1d6a5,
  0x1d6c2,
  0x1d6c3,
  0x1d6c4,
  0x1d6c5,
  0x1d6c6,
  0x1d6c7,
  0x1d6c8,
  0x1d6c9,
  0x1d6ca,
  0x1d6cb,
  0x1d6cc,
  0x1d6cd,
  0x1d6ce,
  0x1d6cf,
  0x1d6d0,
  0x1d6d1,
  0x1d6d2,
  0x1d6d3,
  0x1d6d4,
  0x1d6d5,
  0x1d6d6,
  0x1d6d7,
  0x1d6d8,
  0x1d6d9,
  0x1d6da,
  0x1d6dc,
  0x1d6dd,
  0x1d6de,
  0x1d6df,
  0x1d6e0,
  0x1d6e1,
  0x1d6fc,
  0x1d6fd,
  0x1d6fe,
  0x1d6ff,
  0x1d700,
  0x1d701,
  0x1d702,
  0x1d703,
  0x1d704,
  0x1d705,
  0x1d706,
  0x1d707,
  0x1d708,
  0x1d709,
  0x1d70a,
  0x1d70b,
  0x1d70c,
  0x1d70d,
  0x1d70e,
  0x1d70f,
  0x1d710,
  0x1d711,
  0x1d712,
  0x1d713,
  0x1d714,
  0x1d716,
  0x1d717,
  0x1d718,
  0x1d719,
  0x1d71a,
  0x1d71b,
  0x1d736,
  0x1d737,
  0x1d738,
  0x1d739,
  0x1d73a,
  0x1d73b,
  0x1d73c,
  0x1d73d,
  0x1d73e,
  0x1d73f,
  0x1d740,
  0x1d741,
  0x1d742,
  0x1d743,
  0x1d744,
  0x1d745,
  0x1d746,
  0x1d747,
  0x1d748,
  0x1d749,
  0x1d74a,
  0x1d74b,
  0x1d74c,
  0x1d74d,
  0x1d74e,
  0x1d750,
  0x1d751,
  0x1d752,
  0x1d753,
  0x1d754,
  0x1d755,
  0x1d770,
  0x1d771,
  0x1d772,
  0x1d773,
  0x1d774,
  0x1d775,
  0x1d776,
  0x1d777,
  0x1d778,
  0x1d779,
  0x1d77a,
  0x1d77b,
  0x1d77c,
  0x1d77d,
  0x1d77e,
  0x1d77f,
  0x1d780,
  0x1d781,
  0x1d782,
  0x1d783,
  0x1d784,
  0x1d785,
  0x1d786,
  0x1d787,
  0x1d788,
  0x1d78a,
  0x1d78b,
  0x1d78c,
  0x1d78d,
  0x1d78e,
  0x1d78f,
  0x1d7aa,
  0x1d7ab,
  0x1d7ac,
  0x1d7ad,
  0x1d7ae,
  0x1d7af,
  0x1d7b0,
  0x1d7b1,
  0x1d7b2,
  0x1d7b3,
  0x1d7b4,
  0x1d7b5,
  0x1d7b6,
  0x1d7b7,
  0x1d7b8,
  0x1d7b9,
  0x1d7ba,
  0x1d7bb,
  0x1d7bc,
  0x1d7bd,
  0x1d7be,
  0x1d7bf,
  0x1d7c0,
  0x1d7c1,
  0x1d7c2,
  0x1d7c4,
  0x1d7c5,
  0x1d7c6,
  0x1d7c7,
  0x1d7c8,
  0x1d7c9,
  0x1d7cb,
  0x1df00,
  0x1df01,
  0x1df02,
  0x1df03,
  0x1df04,
  0x1df05,
  0x1df06,
  0x1df07,
  0x1df08,
  0x1df09,
  0x1df0b,
  0x1df0c,
  0x1df0d,
  0x1df0e,
  0x1df0f,
  0x1df10,
  0x1df11,
  0x1df12,
  0x1df13,
  0x1df14,
  0x1df15,
  0x1df16,
  0x1df17,
  0x1df18,
  0x1df19,
  0x1df1a,
  0x1df1b,
  0x1df1c,
  0x1df1d,
  0x1df1e,
  0x1df25,
  0x1df26,
  0x1df27,
  0x1df28,
  0x1df29,
  0x1df2a,
  0x1e922,
  0x1e923,
  0x1e924,
  0x1e925,
  0x1e926,
  0x1e927,
  0x1e928,
  0x1e929,
  0x1e92a,
  0x1e92b,
  0x1e92c,
  0x1e92d,
  0x1e92e,
  0x1e92f,
  0x1e930,
  0x1e931,
  0x1e932,
  0x1e933,
  0x1e934,
  0x1e935,
  0x1e936,
  0x1e937,
  0x1e938,
  0x1e939,
  0x1e93a,
  0x1e93b,
  0x1e93c,
  0x1e93d,
  0x1e93e,
  0x1e93f,
  0x1e940,
  0x1e941,
  0x1e942,
  0x1e943
])

let sizeof_codepoint = (code_point: CodePoint) => {
  if (code_point < 0x7F) {
    1
  } else if (code_point < 0x7FF) {
    2
  } else if (code_point < 0xFFFF) {
    3
  } else {
    4
  }
}

@unsafe
let code_points_to_string = (code_points: List<CodePoint>) => {
  use WasmI32.{ fromGrain, toGrain, (+) as (+.), }
  use Offsets.{ _STR_DATA_OFFSET }
  let string_size = List.reduce(
    (acc, code_point) => sizeof_codepoint(code_point) + acc,
    0,
    code_points,
  )
  
  let str_ptr = DataStructures.allocateString(fromGrain(string_size))
  let str = toGrain(str_ptr) : String
  
  List.reduce(
    (str_ptr, code_point) => match (sizeof_codepoint(code_point)) {
      1 => {
        WasmI32.store8(str_ptr, fromGrain(code_point), 0n)
        str_ptr +. 1n
      },
      2 => {
        WasmI32.store8(str_ptr, fromGrain(0b11000000 | (code_point >> 6)), 0n)
        WasmI32.store8(str_ptr +. 1n, fromGrain(0b10000000 | (code_point & 0b00111111)), 0n)
        str_ptr +. 2n
      },
      3 => {
        WasmI32.store8(str_ptr, fromGrain(0b11100000 | (code_point >> 12)), 0n)
        WasmI32.store8(str_ptr +. 1n, fromGrain(0b10000000 | ((code_point >> 6) & 0b00111111)), 0n)
        WasmI32.store8(str_ptr +. 2n, fromGrain(0b10000000 | (code_point & 0b00111111)), 0n)
        str_ptr +. 3n
      },
      4 => {
        WasmI32.store8(str_ptr, fromGrain(0b11110000 | (code_point >> 18)), 0n)
        WasmI32.store8(str_ptr +. 1n, fromGrain(0b10000000 | ((code_point >> 12) & 0b00111111)), 0n)
        WasmI32.store8(str_ptr +. 2n, fromGrain(0b10000000 | ((code_point >> 6) & 0b00111111)), 0n)
        WasmI32.store8(str_ptr +. 3n, fromGrain(0b10000000 | (code_point & 0b00111111)), 0n)
        str_ptr +. 4n
      },
      _ => fail "Invalid code point: " ++ toString(code_point)
    },
    _STR_DATA_OFFSET +. str_ptr,
    code_points,
  )

  str
}

@unsafe
let charCodeAt = (offset: Number, input: String) => {
  use WasmI32.{
    (+) as (+.),
    (&) as (&.),
    (|) as (|.),
    (<<) as (<<.),
    (==) as (==.),
    geU as (>=.),
    ltU as (<.),
    leU as (<=.),
    toGrain,
    fromGrain,
    load8U,
    load,
  }
  use Offsets.{ _STR_LEN_OFFSET, _STR_DATA_OFFSET }
  let ptr = fromGrain(input)
  let length = fromGrain(String.byteLength(input))
  let offset = fromGrain(offset)

  if (offset >=. length) {
    fail "Invalid offset: " ++ toString(wasmI32ToNumber(offset))
  }

  let first = load8U(ptr, _STR_DATA_OFFSET +. offset)

  let (result, advance) = match (first) {
    first when first <. 0x7Fn => (first, 1n),
    first when (first &. 0b11100000n) ==. 0b11000000n => {
      let second = load8U(ptr, _STR_DATA_OFFSET +. offset +. 1n)
      (
        (first &. 0b00011111n) <<. 6n
        |. (second &. 0b00111111n),
        2n,
      )
    },
    first when (first &. 0b11110000n) ==. 0b11100000n => {
      let second = load8U(ptr, _STR_DATA_OFFSET +. offset +. 1n)
      let third = load8U(ptr, _STR_DATA_OFFSET +. offset +. 2n)
      (
        (first &. 0b00001111n) <<. 12n
        |. (second &. 0b00111111n) <<. 6n
        |. (third &. 0b00111111n),
        3n,
      )
    },
    first when (first &. 0b11111000n) ==. 0b11110000n => {
      let second = load8U(ptr, _STR_DATA_OFFSET +. offset +. 1n)
      let third = load8U(ptr, _STR_DATA_OFFSET +. offset +. 2n)
      let fourth = load8U(ptr, _STR_DATA_OFFSET +. offset +. 3n)
      (
        (first &. 0b00000111n) <<. 18n
        |. (second &. 0b00111111n) <<. 12n
        |. (third &. 0b00111111n) <<. 6n
        |. (fourth &. 0b00111111n),
        4n,
      )
    },
    _otherwise => fail "Invalid UTF-8 sequence: " ++ toString(wasmI32ToNumber(first)),
  } 
  ignore(input)

  match (result) {
    result when result >=. 0xD800n && result <=. 0xDFFFn => {
      let value = wasmI32ToNumber(advance)
      (0xFFFD : CodePoint, value)
    },
    result => {
      let value = wasmI32ToNumber(result)
      let next = wasmI32ToNumber(advance)
      (value, next)
    },
  }
}

provide let is_digit = range(_0, _9)
provide let is_lower = (c: CodePoint) => Set.Immutable.contains(c, lower_set)
provide let is_upper = (c: CodePoint) => Set.Immutable.contains(c, upper_set)

provide let is_letter = is_upper |. is_lower
provide let is_id_start = is_underscore |. is_lower
provide let is_id_continue = is_id_start |. is_digit
provide let is_type_start = is_upper
provide let is_type_continue = is_upper |. is_lower |. is_digit

provide let is_lower_hex_letter = range(_a, _f)
provide let is_upper_hex_letter = range(_A, _F)
provide let is_hex_letter = is_lower_hex_letter |. is_upper_hex_letter
provide let is_hex = is_digit |. is_hex_letter
provide let is_octal = range(_0, _7)
provide let is_binary = exactly(_0) |. exactly(_1)

provide let is_e = exactly(_e)
provide let is_u = exactly(_u)
provide let is_s = exactly(_s)
provide let is_S = exactly(_S)
provide let is_l = exactly(_l)
provide let is_L = exactly(_L)
provide let is_x = exactly(_x)
provide let is_o = exactly(_o)
provide let is_b = exactly(_b)

provide let to_codepoint_iter = (input: String) => {
  Iter.unfold(
    (input, 0, String.byteLength(input)),
    ((input, offset, length)) => {
      print(("Offset: ", offset))
      match (charCodeAt(offset, input)) {
        (code_point, advance) when advance + offset <= length => {
          let result = (code_point, offset)
          let next_state = (input, offset + advance, length)
          print(("Result: ", result))
          Some((next_state, result)) 
        },
        _ => {
          print("Done")
          None
        },
      } 
    }
  )
}

let decimal_codepoint_to_bigint = (code_point: CodePoint) => {
  assert(is_digit(code_point))
  BigInt.fromNumber(code_point - _0)
}

let hex_codepoint_to_bigint = (code_point: CodePoint) => {
  use BigInt.{ (+) as (+.), fromNumber }
  assert(is_hex(code_point))
  match (code_point) {
    _ when is_digit(code_point) => BigInt.fromNumber(code_point - _0),
    _ when is_lower_hex_letter(code_point) => fromNumber(code_point - _a) +. 10t,
    _ when is_upper_hex_letter(code_point) => fromNumber(code_point - _A) +. 10t,
    _ => fail "Not a hex letter: " ++ toString(code_point),
  }
}

let octal_codepoint_to_bigint = (code_point: CodePoint) => {
  assert(is_octal(code_point))
  BigInt.fromNumber(code_point - _0)
}

let binary_codepoint_to_bigint = (code_point: CodePoint) => {
  assert(is_binary(code_point))
  BigInt.fromNumber(code_point - _0)
}

provide enum TokenState {
  Start,
  LexWhitespace(Number),
  LexName(List<CodePoint>, Number),
  LexType(List<CodePoint>, Number),

  LexMinus(Number),

  // Whenever we encounter a `0`, it could be followed by a hex, octal, or binary number.
  // Or it could just be `0`
  LexZeroStart(Number, Bool), // Offset, negative

  LexHex(Number, Bool, BigInt), // Offset, negative, value
  LexOctal(Number, Bool, BigInt),
  LexBinary(Number, Bool, BigInt),
  LexDecimal(Number, Bool, BigInt),

  LexFloatFractionPart(Number, Bool, BigInt, BigInt), // offset, negative, integer, fraction
  LexFloatExponentPartMaybeNegative(Number, Bool, BigInt, BigInt), // offset, negative, integer, fraction
  LexFloatExponentPart(Number, Bool, BigInt, BigInt, Bool, BigInt), // offset, negative, integer, fraction, negative_exponent, exponent

  FinalizeInteger(Number, Bool, BigInt), // Offset, value
  FinalizeIntegerUnsigned(Number, Bool, BigInt), // Offset, value

  LexMultiCharSymbol(Number, List<CodePoint>), // Offset, code points

  UnknownTokenKind(Number),
}

provide type CodePointAccumulator = (TokenState, Number)

provide let code_point_transformer = (
  code_points: Iter<(CodePoint, Number)>,
  map_token = identity,
) => {
  let iterator = Iter.transform(
    (state, (code_point, offset)) => match (state) {
      // Starting state
      Start => match (void) {
        _ when is_whitespace(code_point) => Continue(LexWhitespace(offset)),
        _ when is_id_start(code_point) => Continue(LexName([code_point], offset)),
        _ when is_type_start(code_point) => Continue(LexType([code_point], offset)),
        _ when is_0(code_point) => Continue(LexZeroStart(offset, false)),
        _ when is_digit(code_point) => Continue(LexDecimal(offset, false, decimal_codepoint_to_bigint(code_point))),
        _ when is_minus(code_point) => Continue(LexMinus(offset)),
        _ when is_multi_char_symbol(code_point) => Continue(LexMultiCharSymbol(offset, [code_point])),
        _ when is_reserved_symbol(code_point) => Yield(Symbol(code_points_to_string([code_point]), offset), Start),
        _ => Continue(UnknownTokenKind(offset)),
      },

      // Lexing a whitespace token
      LexWhitespace(offset) => match (code_point) {
        _ when is_whitespace(code_point) => Continue(LexWhitespace(offset)),
        _ => Yield(Whitespace(offset), Start),
      },

      // Lexing a name token
      LexName(code_points, offset) => match (code_point) {
        _ when is_id_continue(code_point) => Continue(LexName([code_point, ...code_points], offset)),
        _ => Yield(Name(code_points_to_string(List.reverse(code_points)), offset), Start),
      },

      LexType(code_points, offset) => match (code_point) {
        _ when is_type_continue(code_point) => Continue(LexType([code_point, ...code_points], offset)),
        _ => Yield(Type(code_points_to_string(List.reverse(code_points)), offset), Start),
      },

      LexZeroStart(offset, negative) => match (code_point) {
        _ when is_x(code_point) => Continue(LexHex(offset, negative, 0t)),
        _ when is_o(code_point) => Continue(LexOctal(offset, negative, 0t)),
        _ when is_b(code_point) => Continue(LexBinary(offset, negative, 0t)),
        _ when is_dot(code_point) => Continue(LexFloatFractionPart(offset, false, 0t, 0t)),
        _ => Retry(FinalizeInteger(offset, false, 0t)),
      },
      
      LexHex(offset, negative, value) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_hex(code_point) => Continue(LexHex(offset, negative, value *. 16t +. hex_codepoint_to_bigint(code_point))),
          _ => Retry(FinalizeInteger(offset, negative, value)),
        }
      },

      LexOctal(offset, negative, value) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_octal(code_point) => Continue(LexOctal(offset, negative, value *. 8t +. octal_codepoint_to_bigint(code_point))),
          _ => Retry(FinalizeInteger(offset, negative, value)),
        }
      },

      LexBinary(offset, negative, value) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_binary(code_point) => Continue(LexBinary(offset, negative, value *. 2t +. binary_codepoint_to_bigint(code_point))),
          _ => Retry(FinalizeInteger(offset, negative, value)),
        }
      },

      LexDecimal(offset, negative, value) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_digit(code_point) => Continue(LexDecimal(offset, negative, value *. 10t +. decimal_codepoint_to_bigint(code_point))),
          _ when is_dot(code_point) => Continue(LexFloatFractionPart(offset, false, value, 0t)),
          _ => Retry(FinalizeInteger(offset, negative, value)),
        }
      },

      LexMinus(offset) => match (code_point) {
        _ when is_0(code_point) => Continue(LexZeroStart(offset, true)),
        _ when is_digit(code_point) => Continue(LexDecimal(offset, true, decimal_codepoint_to_bigint(code_point))),
        _ when is_multi_char_symbol(code_point) => Continue(LexMultiCharSymbol(offset, [code_point, _minus])),
        // Whatever follows needs to be "re-lexed," so yield the symbol, but retry the current value
        // with a new state.
        _ => YieldRetry(Symbol("-", offset), Start),
      },

      LexMultiCharSymbol(offset, code_points) => match (code_point) {
        _ when is_multi_char_symbol(code_point) => Continue(LexMultiCharSymbol(offset, [code_point, ...code_points])),
        // Whatever follows needs to be "re-lexed," so yield the symbol, but retry the current value
        // with a new state.
        _ => YieldRetry(Symbol(code_points_to_string(List.reverse(code_points)), offset), Start),
      },

      // Floats
      LexFloatFractionPart(offset, negative, integer, fraction) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_digit(code_point) => Continue(LexFloatFractionPart(offset, negative, integer, fraction *. 10t +. decimal_codepoint_to_bigint(code_point))),
          _ when is_e(code_point) => Continue(LexFloatExponentPartMaybeNegative(offset, negative, integer, fraction)),
          // Whatever follows needs to be "re-lexed," so yield the symbol, but retry the current value
          _ => YieldRetry(Float(negative, integer, fraction, false, 0t, offset), Start), // with a new state.
        }
      },

      LexFloatExponentPartMaybeNegative(offset, negative, integer, fraction) => {
        match (code_point) {
          _ when is_plus(code_point) => Continue(LexFloatExponentPart(offset, negative, integer, fraction, false, 0t)),
          _ when is_minus(code_point) => Continue(LexFloatExponentPart(offset, negative, integer, fraction, true, 0t)),
          _ when is_digit(code_point) => Continue(LexFloatExponentPart(offset, negative, integer, fraction, false, decimal_codepoint_to_bigint(code_point))),
          _ => Continue(UnknownTokenKind(offset)),
        }
      },

      LexFloatExponentPart(offset, negative, integer, fraction, negative_exponent, exponent) => {
        use BigInt.{ (+) as (+.), (*) as (*.) }
        match (code_point) {
          _ when is_digit(code_point) => Continue(LexFloatExponentPart(offset, negative, integer, fraction, negative_exponent, exponent *. 10t +. decimal_codepoint_to_bigint(code_point))),
          // Whatever follows needs to be "re-lexed," so yield the symbol, but retry the current value
          // with a new state.
          _ => YieldRetry(Float(negative, integer, fraction, negative_exponent, exponent, offset), Start),
        }
      },

      FinalizeInteger(offset, negative, value) => {
        match (code_point) {
          _ when is_u(code_point) => Continue(FinalizeIntegerUnsigned(offset, negative, value)),
          _ when is_s(code_point) => Yield(Integer(negative, value, true, 8, offset), Start),
          _ when is_S(code_point) => Yield(Integer(negative, value, true, 16, offset), Start),
          _ when is_l(code_point) => Yield(Integer(negative, value, true, 32, offset), Start),
          _ when is_L(code_point) => Yield(Integer(negative, value, true, 64, offset), Start),
          _ => YieldRetry(Integer(negative, value, true, 32, offset), Start),
        }
      },

      FinalizeIntegerUnsigned(offset, negative, value) => {
        match (code_point) {
          _ when is_s(code_point) => Yield(Integer(negative, value, false, 8, offset), Start),
          _ when is_S(code_point) => Yield(Integer(negative, value, false, 16, offset), Start),
          _ when is_l(code_point) => Yield(Integer(negative, value, false, 32, offset), Start),
          _ when is_L(code_point) => Yield(Integer(negative, value, false, 64, offset), Start),
          _ => Continue(UnknownTokenKind(offset)),
        }
      },

      UnknownTokenKind(offset) => match (code_point) {
        _ when !is_whitespace(code_point) => Continue(UnknownTokenKind(offset)),
        _ => YieldRetry(Unknown(offset), Start),
      },
    },
    Start,
    code_points,
  )

  Iter.map(map_token, iterator)
}

provide let lex = (input: String) => code_point_transformer(
  to_codepoint_iter(input),
  map_token = (token) => match (token) {
    Name("let", offset) => Keyword("let", offset),
    Name("mut", offset) => Keyword("mut", offset),
    Name("const", offset) => Keyword("const", offset),
    Name("fn", offset) => Keyword("fn", offset),
    Name("match", offset) => Keyword("match", offset),
    Name("if", offset) => Keyword("if", offset),
    Name("else", offset) => Keyword("else", offset),
    Name("when", offset) => Keyword("when", offset),
    Name("while", offset) => Keyword("while", offset),
    Name("for", offset) => Keyword("for", offset),
    Name("in", offset) => Keyword("in", offset),
    Name("return", offset) => Keyword("return", offset),
    Name("break", offset) => Keyword("break", offset),
    Name("continue", offset) => Keyword("continue", offset),
    Name("true", offset) => Keyword("true", offset),
    Name("false", offset) => Keyword("false", offset),
    Name("nil", offset) => Keyword("nil", offset),
    Name("type", offset) => Keyword("type", offset),
    Name("enum", offset) => Keyword("enum", offset),
    Name("record", offset) => Keyword("record", offset),
    Name("namespace", offset) => Keyword("namespace", offset),
    t => t,
  },
)
